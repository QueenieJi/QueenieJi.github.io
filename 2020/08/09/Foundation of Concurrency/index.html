<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Foundation of Concurrency - QueenieJi</title><meta description="There are some learning notes about UNSW COMP3151&amp;#x2F;9154. Main contents are based on Ben Ari’s book Principles of concurrent and distributed programming algorithms and models and lecture slides."><meta property="og:type" content="blog"><meta property="og:title" content="UNSW CompSci Student"><meta property="og:url" content="http://queenieji.github.io/2020/08/09/Foundation%20of%20Concurrency/"><meta property="og:site_name" content="QueenieJi"><meta property="og:description" content="There are some learning notes about UNSW COMP3151&amp;#x2F;9154. Main contents are based on Ben Ari’s book Principles of concurrent and distributed programming algorithms and models and lecture slides."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://i.loli.net/2020/08/10/THt2jK1EXgCZ6Va.png"><meta property="og:image" content="https://i.loli.net/2020/08/10/tR6rqExuNAo2MjD.png"><meta property="article:published_time" content="2020-08-09T04:00:00.000Z"><meta property="article:modified_time" content="2020-08-11T02:45:02.950Z"><meta property="article:author" content="Queenie Ji"><meta property="article:tag" content="Concurrency"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://i.loli.net/2020/08/10/THt2jK1EXgCZ6Va.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://queenieji.github.io/2020/08/09/Foundation%20of%20Concurrency/"},"headline":"QueenieJi","image":["https://i.loli.net/2020/08/10/THt2jK1EXgCZ6Va.png","https://i.loli.net/2020/08/10/tR6rqExuNAo2MjD.png"],"datePublished":"2020-08-09T04:00:00.000Z","dateModified":"2020-08-11T02:45:02.950Z","author":{"@type":"Person","name":"Queenie Ji"},"description":"There are some learning notes about UNSW COMP3151&#x2F;9154. Main contents are based on Ben Ari’s book Principles of concurrent and distributed programming algorithms and models and lecture slides."}</script><link rel="canonical" href="http://queenieji.github.io/2020/08/09/Foundation%20of%20Concurrency/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="QueenieJi" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/project">Project</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/QueenieJi"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-09T04:00:00.000Z" title="2020-08-09T04:00:00.000Z">2020-08-09</time><span class="level-item"><a class="link-muted" href="/categories/notes/">notes</a></span><span class="level-item">21 minutes read (About 3209 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Foundation of Concurrency</h1><div class="content"><blockquote>
<p>There are some learning notes about UNSW COMP3151/9154. Main contents are based on Ben Ari’s book <em>Principles of concurrent and distributed programming algorithms and models</em> and lecture slides.</p>
</blockquote>
<a id="more"></a>
<h1 id="Final-Revision"><a href="#Final-Revision" class="headerlink" title="Final Revision"></a>Final Revision</h1><h2 id="Linear-Temporal-Logic-LTL"><a href="#Linear-Temporal-Logic-LTL" class="headerlink" title="Linear Temporal Logic (LTL)"></a>Linear Temporal Logic (LTL)</h2><p>A linear temporal property is a set of <em>behaviours</em>.</p>
<h3 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h3><p><strong>Definition:</strong></p>
<p>A logic is a formal language designed to express logical reasoning. Like any formal language, logics have a <strong>syntax</strong> and <strong>semantics</strong>.</p>
<p><strong>In concurrency:</strong><br>take <strong>time</strong> into account</p>
<h3 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h3><p>Semantics are a mathematical representation of the <strong>meaning</strong> of a piece of syntax. There are many ways of giving a logic semantics, but we will use <strong>models</strong>.</p>
<h3 id="LTL"><a href="#LTL" class="headerlink" title="LTL"></a>LTL</h3><p><strong>Linear temporal logic (LTL)</strong> is a logic designed to describe linear time properties.</p>
<p><strong>Modal or temporal operators</strong></p>
<p>If $φ$ is an LTL formula, then $\bigcirc φ$ is an LTL formula.<br>If $φ, ψ$ are LTL formulae, then $φ U ψ$ is an LTL formula.</p>
<p>circle: next<br>U: until<br>describe a behaviour</p>
<ul>
<li>$\bigcirc$<br>No Orange -&gt; it’s not orange right now<br>$\bigcirc$ Orange -&gt; it’s orange in the next state</li>
<li>U<br>orange U blue -&gt; at some point in the future (don’t have to hold forever and the future <strong>can be now</strong>) , the right will be true, before that, the left is true</li>
</ul>
<h3 id="LTL-Semantics"><a href="#LTL-Semantics" class="headerlink" title="LTL Semantics"></a>LTL Semantics</h3><p>Let $σ = σ_0σ_1σ_2σ_3σ_4σ_5$ . . . be a behaviour. Then define notation: </p>
<ul>
<li><p>$σ|_0 = σ$</p>
</li>
<li><p>$σ|_1 = σ_1σ_2σ_3σ_4σ_5 . . . $</p>
</li>
<li><p>$σ|_{n+1} = (σ|_1)|_n$</p>
</li>
</ul>
<p><strong>Semantics</strong></p>
<p>The models of LTL are <strong>behaviours</strong>. For atomic propositions, we just look at the <strong>first state</strong>. We often identify states with the <strong>set of atomic propositions they satisfy.</strong></p>
<p>$σ\vDash p ⇔ p∈σ_0$</p>
<p>$σ\vDash φ∧ψ  ⇔ σ \vDash φ$ and $σ\vDashψ$</p>
<p>$σ\vDash¬φ ⇔ σ\not\vDashφ$</p>
<p>$σ|=\bigcirc φ  ⇔σ|_1\vDashφ$  </p>
<p>$σ|=φ U ψ ⇔ $ There exists an $i$ such that $ σ|_i \vDashψ$ </p>
<p>​                        and for all $j &lt; i$, $σ|_j \vDash φ$ </p>
<p>We say $P \vDash φ$ iff $\forall \varphi \in P$ and $σ \vDash φ$.</p>
<h3 id="Derived-Operator"><a href="#Derived-Operator" class="headerlink" title="Derived Operator"></a>Derived Operator</h3><ul>
<li><p>The operator $\Diamond φ$ (“finally” or “eventually”) says that $φ$ will be true at some point. </p>
</li>
<li><p>The operator $\Box \varphi$ (“globally” or “always”) says that $\varphi$ is <strong>always</strong> true from now on.</p>
</li>
</ul>
<p>operator <code>diamond</code> =&gt; eventually<br>$\Diamond φ=$ T $U φ$<br>we don’t care about the left hand side =&gt; True</p>
<p>operator <code>box</code> =&gt; for any time from now on, phi will hold $\Box \varphi = \neg \Diamond \neg φ$ </p>
<p><strong>Exercise:</strong></p>
<p>Infinitely Often<br>= always eventually phi<br>= square diamond phi</p>
<h2 id="Safety-Liveness"><a href="#Safety-Liveness" class="headerlink" title="Safety/Liveness"></a>Safety/Liveness</h2><ol>
<li><p>A <strong>safety</strong> property states that something <strong>bad</strong> does not happen. </p>
<p>These are properties that may be violated by a finite prefix of a behaviour.</p>
</li>
<li><p>A <strong>liveness</strong> property states that something <strong>good</strong> will happen.</p>
<p>These are properties that can always be satisfied eventually</p>
</li>
</ol>
<h2 id="Kripke-Structures-KS"><a href="#Kripke-Structures-KS" class="headerlink" title="Kripke Structures (KS)"></a>Kripke Structures (KS)</h2><p>These traces that we have examined are still sequences of actions, not states. Behaviours, however, are sequences of states.</p>
<p>Normally, to convert our labelled transition systems into something we can reason about in LTL, we first translate them into an automata called a Kripke Structure. A Kripke structure is a 4-tuple $(S,I,↦,L)$ which contains a set of states $S$, an initial state $I$, a transition relation $↦$ which, unlike a labelled transition system, does not have any action labels on the transitions, and a labelling function $L$ which associates to every state $S$ a (set of) atomic propositions – these are the atomic propositions we use in our LTL formulae. A Kripke structure for an OS process behaviour was actually shown in the lecture on temporal logic in Week 1, I just never told you it was a Kripke structure.</p>
<p>Kripke Structures deal with states, not transition actions. This means, to translate from a labelled transition system to a Kripke structure, we need a way to move labels from transitions to states.</p>
<p>The simplest translation is due to de Nicola and Vaandrager, where each transition $s_i\xrightarrow[]{a}s_j$ in the LTS is split into two in the Kripke Structure: $s_i→X$ and $X→s_j$, where X is a new state that is labelled with a.</p>
<p>Because this converts existing LTS locations into blank, unlabelled states in the Kripke structure, this introduces problems with the next state operator in LTL. For this reason (and others) we usually consider LTL without the next state operator in this field.</p>
<p>Normally with LTL, we require that Kripke structures have no deadlock states, that is, states with no outgoing transitions. The usual solution here is to add a self loop to all terminal states.</p>
<p>We can extract our normal notion of a behaviour by using the progress completeness criterion. Because of the restriction above, the progress criterion is equivalent to examining only the infinite runs of the automata.</p>
<h2 id="Calculus-of-Communicating-Systems-CCS"><a href="#Calculus-of-Communicating-Systems-CCS" class="headerlink" title="Calculus of Communicating Systems (CCS)"></a>Calculus of Communicating Systems (CCS)</h2><h3 id="CCS"><a href="#CCS" class="headerlink" title="CCS"></a>CCS</h3><p>The <code>Calculus of Communicating Systems</code>:</p>
<ul>
<li>Is a <strong>process algebra</strong>, a simple formal language to describe concurrent systems. </li>
<li>Is given semantics in terms of labelled transition systems. </li>
<li>Was developed by Turing-award winner Robin Milner in the 1980s. </li>
<li>Has an abstract view of synchronization that applies well to message passing</li>
</ul>
<h3 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h3><p>Processes in CCS are defined by equations:</p>
<p><strong>Example:</strong></p>
<p>The equation: <strong>CLOCK</strong> = tick </p>
<p>defines a process <strong>CLOCK</strong> that simply executes the action “tick” and then terminates. This process corresponds to the first location in this labelled transition system (LTS):<br>$$<br>\begin{align}<br>&amp;\bullet\\<br>&amp;\Bigg\downarrow\text{tick}\\<br>&amp;\bullet<br>\end{align}<br>$$<br>An LTS is like a transition diagram, save that our transitions are just abstract actions and we have no initial or final location.</p>
<h3 id="Action-Prefixing"><a href="#Action-Prefixing" class="headerlink" title="Action Prefixing"></a>Action Prefixing</h3><p><strong>Definition</strong></p>
<p>If a is an action and P is a process, then $x.P$ is a process that executes $x$ before $P$. This brackets to the right, so: $$x.y.z.P = x.(y.(z.P))$$</p>
<p><strong>Stopping</strong></p>
<p>More precisely, we should write: <strong>CLOCK2</strong> $=$ tick.tock.<strong>STOP</strong> where <strong>STOP</strong> is the trivial process with no transitions.</p>
<h3 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h3><p>Up to now, all processes make a finite number of transitions and then terminate. Processes that can make a infinite number of transitions can be pictured by allowing loops:</p>
<p><strong>CLOCK4</strong> = tick.<strong>CLOCK4</strong></p>
<p><strong>CLOCK5</strong> = tick.tock.<strong>CLOCK5</strong></p>
<p>We accomplish loops in CCS using <code>recursion</code>.</p>
<h3 id="Equality-of-Processes"><a href="#Equality-of-Processes" class="headerlink" title="Equality of Processes"></a>Equality of Processes</h3><p><strong>Informal Definition</strong> </p>
<p>We consider two process to be equal if an external observer cannot distinguish them by their actions. We will refine this definition later</p>
<p>These two processes are physically different:</p>
<p><a href="https://sm.ms/image/THt2jK1EXgCZ6Va" target="_blank"><img src="https://i.loli.net/2020/08/10/THt2jK1EXgCZ6Va.png" ></a></p>
<p>But they both have the same behaviour — an infinite sequence of “tick” transitions</p>
<h3 id="Choice"><a href="#Choice" class="headerlink" title="Choice"></a>Choice</h3><p>Definition If P and Q are processes then P + Q is a process which can either behave as the process P or the process Q.</p>
<p>Choice Equalities Observe that we have the following identities about choice:<br>$$<br>\begin{align}<br>&amp;P + (Q + R) = (P + Q) + R &amp;\text{(associativity)}\\<br>&amp;P + Q = Q + P &amp;\text{(commutativity)}\\<br>&amp;P + \textbf{STOP} = P &amp;\text{(neutral element)}\\<br>&amp;P + P = P &amp;\text{(idempotence)}\\<br>\end{align}<br>$$</p>
<h3 id="Bisimulation-equivalence"><a href="#Bisimulation-equivalence" class="headerlink" title="Bisimulation equivalence"></a>Bisimulation equivalence</h3><p>Our notion of equality without this equation is called (strong) bisimulation equivalence or (strong) bisimilarity</p>
<h3 id="Partial-trace-equivalence"><a href="#Partial-trace-equivalence" class="headerlink" title="Partial trace equivalence"></a>Partial trace equivalence</h3><p>We examined the two CCS processes $a⋅(b+c)$ and $a⋅b+a⋅c$ and concluded that LTL would not be able to distinguish these two processes, even though they are not considered equal (bisimilar) in CCS.</p>
<p>If we were to try to add the equation $a⋅(P+Q)=a⋅P+a⋅Q$ into CCS, then we would identify those two processes above, but we would also identify $a⋅b+a$ with $a⋅b$, and clearly one of these satisfies $◊b$ and the other doesn’t!</p>
<p>This is because the semantic equivalence we get by adding that equation is called <em>partial trace equivalence</em>. As mentioned in lectures, partial trace equivalence is like looking at all the possible sequences of actions (traces) in the process, including those sequences that do not take available transitions. So, the traces of $a⋅b+a$ are $ϵ$ (the empty trace), $a$, and $ab$ – exactly the same as the partial traces of $a⋅b$.</p>
<p>Because partial trace equivalence includes these incomplete traces, using it is basically giving up on the vital <em>progress</em> assumption. Progress is the assumption that a process will take an action if one is available.</p>
<h3 id="Parallel-Composition"><a href="#Parallel-Composition" class="headerlink" title="Parallel Composition"></a>Parallel Composition</h3><p>If P and Q are processes then P | Q is the parallel composition of their processes — i.e. the non-deterministic interleaving of their actions</p>
<h3 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h3><p>In CCS, every action a has an opposing coaction $\bar a$ (and $a$ = $\bar {\bar a}$)</p>
<p>It is a convention to think of an action as an <strong>output</strong> event and a coaction as an <strong>input</strong> event. If a system can execute both an action and its coaction, it may execute them both simultaneously by taking an internal transition marked by the special action $τ$</p>
<h3 id="Expansion-Theorem"><a href="#Expansion-Theorem" class="headerlink" title="Expansion Theorem"></a>Expansion Theorem</h3><p>Let $P$ and $Q$ be processes. By expanding recursive definitions and using our existing equations for choice we can express $P$ and $Q$ as n-ary choices of action prefixes:<br>$$<br>P =\Sigma_{i \in I} αi. Pi \text{ and } Q =\Sigma_{j∈J}βj.Qj.<br>$$</p>
<p>Then, the parallel composition can be expressed as follows:</p>
<p>$$<br>P | Q = \Sigma_{i∈I} αi .(P_i | Q) + \Sigma_{j∈J} βj .(P | Q_j) + \Sigma_{i∈I, j∈J, αi=\bar β_j} τ.(P_i | Q_j).<br>$$</p>
<h3 id="Restriction"><a href="#Restriction" class="headerlink" title="Restriction"></a>Restriction</h3><p>If P is a process and a is an action (not $τ$ ), then $P$ \ $a$ is the same as the process P except that the actions $a$ and $\bar a$ may not be executed. We have<br>$$<br>(a.P) \backslash b = a.(P \ b) \text{ if } a \not ∈ {b, \bar b}<br>$$</p>
<h3 id="Inference-Rules"><a href="#Inference-Rules" class="headerlink" title="Inference Rules"></a>Inference Rules</h3><p>In logic we often write:<br>$$<br>\frac{A_1\qquad A_2\qquad …\qquad A_n}{C}<br>$$<br>To indicate that $C$ can be proved by proving all assumptions $A_1$ through $A_n$. For example, the classical logical rule of modus ponens is written as follows:<br>$$<br>\frac{A\implies B \qquad A}{B} \text{MODUS PONENS}<br>$$</p>
<h3 id="Operational-Semantics"><a href="#Operational-Semantics" class="headerlink" title="Operational Semantics"></a>Operational Semantics</h3><p>$$<br>\begin{align}<br>&amp;\frac{}{a.P\xrightarrow[]{a}P}\text{ACT}<br>&amp;\frac{P\xrightarrow[]{a}P’}{P + Q\xrightarrow[]{a}P’}\text{CHOICE}_1<br>&amp;\frac{Q\xrightarrow[]{a}Q’}{P+Q\xrightarrow[]{a}Q’}\text{CHOICE}_2\\<br>&amp;\frac{P\xrightarrow[]{a}P’}{P|Q\xrightarrow[]{a}P’|Q}\text{PAR}_1<br>&amp;\frac{Q\xrightarrow[]{a}Q’}{P|Q\xrightarrow[]{a}P|Q’}\text{PAR}_2<br>&amp;\frac{P\xrightarrow[]{a}P’\qquad Q\xrightarrow[]{\bar a}Q’}{P|Q \xrightarrow[]{τ}P’|Q’}\text{SYNC}\\<br>&amp;&amp;\frac{P\xrightarrow[]{a}P’\qquad a\not \in {b, \bar b}}{P\backslash b \xrightarrow[]{a}P’\backslash b}\text{RESTRICT}<br>\end{align}<br>$$</p>
<h3 id="Bisimulation-Equivalence"><a href="#Bisimulation-Equivalence" class="headerlink" title="Bisimulation Equivalence"></a>Bisimulation Equivalence</h3><p>Two processes (or locations) P and Q are <strong>bisimilar</strong> iff they can do the same actions and those actions themselves lead to bisimilar processes. All of our previous equalities can be proven by induction on the semantics here.</p>
<h3 id="Proof-Trees"><a href="#Proof-Trees" class="headerlink" title="Proof Trees"></a>Proof Trees</h3><p><a href="https://sm.ms/image/tR6rqExuNAo2MjD" target="_blank"><img src="https://i.loli.net/2020/08/10/tR6rqExuNAo2MjD.png" ></a></p>
<h3 id="Value-Passing"><a href="#Value-Passing" class="headerlink" title="Value Passing"></a>Value Passing</h3><p>We introduce synchronous channels into CCS by allowing actions and coactions to take parameters.<br>$$<br>\begin{align}<br>&amp;\text{Actions}: &amp;a(3)&amp; &amp;c(15)&amp; &amp;x(\text{True}) . . . \\<br>&amp;\text{Coactions}: &amp;\bar a(x)&amp; &amp;\bar c(y)&amp; &amp;\bar c(\bar z) . . .<br>\end{align}<br>$$<br>The parameter of an action is the value to be sent, and the parameter of a coaction is the variable in which the received value is stored.</p>
<p><strong>Example:</strong></p>
<p>A one-cell sized buffer is implemented as:<br>$$<br>\textbf {BUFF} = \overline{\text{in}}(x).\text{out}(x).\textbf{BUFF}<br>$$<br>Larger buffers can be made by stitching multiple <strong>BUFF</strong> processes together! This is how we model asynchronous communication in CCS.</p>
<h3 id="Merge-and-Guards"><a href="#Merge-and-Guards" class="headerlink" title="Merge and Guards"></a>Merge and Guards</h3><p>To do a deterministic (fair) merge, we would need some way to check if one value is larger than another. Rather than add <strong>if</strong> statements, we add the notion of a <em>guard</em></p>
<p><strong>Definition</strong></p>
<p>If $P$ is a value-passing $CCS$ process and $\varphi$ is a formula about the variables in scope, then [$\varphi$]P is a process that executes just like P if $\varphi$ is holds for the current state and like <strong>STOP</strong> otherwise.</p>
<p>We can define an <strong>if</strong> statement like so: </p>
<p><strong>if</strong> $\varphi$ <strong>then</strong> P <strong>else</strong> Q ≡ ([$\varphi$].P) + ([¬$\varphi$].Q)</p>
<h3 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h3><p><strong>Definition</strong> </p>
<p>If P is a process and x is a variable in the state, and e is an expression, then $[![x := e]!]$ P is is the same as P except that it first updates the variable x to have the value e before making a transition.</p>
<h2 id="LTS-Labelled-Transition-Systems"><a href="#LTS-Labelled-Transition-Systems" class="headerlink" title="LTS Labelled Transition Systems"></a>LTS Labelled Transition Systems</h2><h3 id="Transition-Diagrams"><a href="#Transition-Diagrams" class="headerlink" title="Transition Diagrams"></a>Transition Diagrams</h3><p>Definition A transition diagram is a tuple (L,T,s,t) where: </p>
<ul>
<li>L is a set of locations (program counter values). </li>
<li>s ∈ L is a entry location. </li>
<li>t ∈ L is a exit location. </li>
<li>T is a set of transitions. </li>
</ul>
<p>A transition is written as $l_i \xrightarrow[]{\text{g;f}} l_j$ where:</p>
<ul>
<li>$l_i$ and $l_j$ are locations.</li>
<li>g is a guard Σ → B (state to boolean)</li>
<li>f is a state update Σ → Σ. (State to state)</li>
</ul>
<h3 id="Floyd-Verification"><a href="#Floyd-Verification" class="headerlink" title="Floyd Verification"></a>Floyd Verification</h3><p>Recall the definition of a Hoare triple for partial correctness:<br>$$<br>{\varphi} P {ψ}<br>$$<br>This states that if the program P successfully executes from a starting state satisfying $\varphi$, the result state will satisfy $ψ$. </p>
<p>Observe that this is a <strong>safety property</strong>. </p>
<p>Verifying Partial Correctness</p>
<p>Given a transition diagram (L,T,s,t): </p>
<ol>
<li><p>Associate with each location $l ∈ L$ an assertion $Q(l) : Σ → B$. </p>
</li>
<li><p>Prove that this assertion network is inductive, that is: For each transition in T $l_i \xrightarrow[]{\text{g;f}} l_j$ show that:<br>$$<br>Q(l_i) ∧ g ⇒ Q(l_j) ◦ f<br>$$</p>
</li>
<li><p>Show that $\varphi ⇒ Q(s)$ and $Q(t) ⇒ ψ$.</p>
</li>
</ol>
<h3 id="Adding-Concurrency"><a href="#Adding-Concurrency" class="headerlink" title="Adding Concurrency"></a>Adding Concurrency</h3><p><strong>Parallel Composition</strong></p>
<p>Given two processes P and Q with transition diagrams (LP,TP,sP,tP) and (LQ,TQ,sQ,tQ), the <em>parallel composition</em> of $P$ and $Q$, written $P || Q$ is defined as (L,T,s,t) where:</p>
<ul>
<li>$L = L_P × L_Q$</li>
<li>$s = s_Ps_Q $</li>
<li>$t = t_Pt_Q $</li>
<li>$p_iq_i\xrightarrow[]{\text{g;f}}p_jq_i ∈ T$ if $p_i \xrightarrow[]{\text{g;f}} p_j ∈ TP $</li>
<li>$p_iq_i \xrightarrow[]{\text{g;f}} p_iq_j ∈ T$ if $q_i \xrightarrow[]{\text{g;f}} q_j ∈ TQ$</li>
</ul>
<p>is the parallel composition “associative” and “commutative”, that is to define the parallel composition of N processes, we can just iterate parallel composition of 2 processes and no matter how we do it, we arrive at the “same” result? <strong>Yes</strong></p>
<h3 id="State-Space-Explosion"><a href="#State-Space-Explosion" class="headerlink" title="State Space Explosion"></a>State Space Explosion</h3><p> <strong>Problem</strong></p>
<p>Then number of locations and transitions grows exponentially as the number of processes increases. </p>
<p>We can only use Floyd’s method directly on the parallel composition (product) diagram in the most basic examples. </p>
<p><strong>Our Solution</strong></p>
<p> We will instead use a method that allows us to define only inductive assertion networks for P and Q individually, and, by proving some non-interference properties derive an inductive network for P || Q automatically. This means we won’t have to draw that large product diagram!</p>
<h3 id="Owicki-Gries-Method"><a href="#Owicki-Gries-Method" class="headerlink" title="Owicki-Gries Method"></a>Owicki-Gries Method</h3><p><strong>Steps</strong></p>
<p>To show ${ϕ} P || Q {ψ}$: </p>
<ol>
<li><p>Define local assertion networks P and Q for both processes. Show that they’re inductive. </p>
</li>
<li><p>For each location $p ∈ L_P$, show that $P(p)$ is not falsified by any transition of Q. That is, for each $q \xrightarrow[]{\text{g;f}} q’ ∈ TQ$:</p>
<p>$P(p) ∧ Q(q) ∧ g ⇒ P(p) ◦ f$</p>
</li>
<li><p>Vice versa for Q. </p>
</li>
<li><p>Show that $ϕ ⇒ P(s_P) ∧ Q(s_Q)$ and $P(t_P) ∧ Q(t_Q) ⇒ ψ$.</p>
</li>
</ol>
<h3 id="One-Big-Invariant"><a href="#One-Big-Invariant" class="headerlink" title="One Big Invariant"></a>One Big Invariant</h3><p>Imagine assertion network(s) where every assertion is the same: An invariant.</p>
<p><strong>Benefit</strong>: We don’t need to prove interference freedom — the local verification conditions already show that the invariant is preserved.</p>
<h2 id="Compeleteness-criteria"><a href="#Compeleteness-criteria" class="headerlink" title="Compeleteness criteria"></a>Compeleteness criteria</h2><h3 id="Progress"><a href="#Progress" class="headerlink" title="Progress"></a>Progress</h3><p>A simple way to view progress as a completeness criteria is that it says a path is complete iff it is infinite or if it ends in a state with no outgoing transitions. This rules out all paths which end in states where they could take an outgoing transition but don’t.</p>
<h3 id="Weak-Fairness"><a href="#Weak-Fairness" class="headerlink" title="Weak Fairness"></a>Weak Fairness</h3><p>Weak and strong fairness are defined in terms of tasks. A task is a set of transitions.</p>
<p>Weak fairness as a property of paths can be expressed by the LTL formulas<br>$◻(◻(\text{enabled}(t))⇒◊(\text{taken}(t)))$<br>for each task $t$. Here $\text{enabled}(t)$ is an atomic proposition that is true if a transition in $t$ is enabled. Likewise $\text{taken}(t)$ holds if $t$ is taken in that state.</p>
<p>Given a process $P=a⋅P+b$, weak fairness would state that eventually $b$ must occur, as we would not be able to loop infinitely around $a$, never taking the (forever enabled) $b$ transition.</p>
<p>Viewed as a completeness criterion, weak fairness rules out all traces which do not obey the property above. Note that it implies progress, because any trace that will eventually take a forever enabled transition will surely not be able to sit in a state without taking an available transition.</p>
<h3 id="Strong-Fairness"><a href="#Strong-Fairness" class="headerlink" title="Strong Fairness"></a>Strong Fairness</h3><p>Strong fairness is similar to weak fairness, except that the property has one extra operator:<br>$◻(◻◊(\text{enabled}(t))⇒◊(\text{taken}(t)))$<br>This is saying that our task $t$ does not have to be forever enabled, just enabled infinitely often. This means a process can go away and come back. For example, the process $P=a⋅a⋅P+b$ would not eventually do b under weak fairness, as after one a the b transition is no longer enabled. However because the infinite a path has b available infinitely often, strong fairness would require that b is eventually taken.</p>
<p>Viewed as a completeness criterion, this rules out all properties that don’t obey the property above. It can be proven in LTL that strong fairness implies weak fairness.</p>
<h3 id="Justness"><a href="#Justness" class="headerlink" title="Justness"></a>Justness</h3><p>Justness is a slightly harder concept to formalise. It is weaker than both strong and weak fairness, but stronger than progress.</p>
<p>Essentially, it is a criterion that says that individual components should be able to make progress on their own. For example, imagine a system that consists of three components, one which always does a, another which always does b, and another which synchronises with a:<br>$$<br>A=a⋅A\\<br>B=b⋅B\\<br>C=\bar a⋅A\\<br>\text{𝖲𝗒𝗌𝗍𝖾𝗆}=A|B|C<br>$$<br>Now, a valid trace of this system would be simply $bbbbb⋯$ forever. This would satisfy progress, as a transition is always being taken. However, the actions a and $\bar a$ that could occur, and the communication $τ$ transition that could between A and C are never taken in this trace. Justness says that each component of the system will always make progress if their resources are available. In other words, B doing unrelated b moves should never prevent A and C from communicating.</p>
<p>Viewed as a completeness criterion, this is stronger than progress, as it is essentially the same as progress except applied locally, rather than globally. It is weaker than weak fairness, as justness would not require that $A=a⋅A+b$ eventually does a b, as all transitions are from the same component (A).</p>
<h2 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h2></div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Concurrency/">Concurrency</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/08/10/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84blog/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">建立自己的blog</span></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Queenie Ji"></figure><p class="title is-size-4 is-block line-height-inherit">Queenie Ji</p><p class="is-size-6 is-block">UNSW CompSci Student</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>A place</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Category</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/QueenieJi" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/QueenieJi"><i class="fab fa-github"></i></a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Concurrency/"><span class="tag">Concurrency</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/blog-page/"><span class="tag">blog page</span><span class="tag is-grey-lightest">2</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#Final-Revision"><span class="mr-2">1</span><span>Final Revision</span></a><ul class="menu-list"><li><a class="is-flex" href="#Linear-Temporal-Logic-LTL"><span class="mr-2">1.1</span><span>Linear Temporal Logic (LTL)</span></a><ul class="menu-list"><li><a class="is-flex" href="#Logic"><span class="mr-2">1.1.1</span><span>Logic</span></a></li><li><a class="is-flex" href="#Semantics"><span class="mr-2">1.1.2</span><span>Semantics</span></a></li><li><a class="is-flex" href="#LTL"><span class="mr-2">1.1.3</span><span>LTL</span></a></li><li><a class="is-flex" href="#LTL-Semantics"><span class="mr-2">1.1.4</span><span>LTL Semantics</span></a></li><li><a class="is-flex" href="#Derived-Operator"><span class="mr-2">1.1.5</span><span>Derived Operator</span></a></li></ul></li><li><a class="is-flex" href="#Safety-Liveness"><span class="mr-2">1.2</span><span>Safety/Liveness</span></a></li><li><a class="is-flex" href="#Kripke-Structures-KS"><span class="mr-2">1.3</span><span>Kripke Structures (KS)</span></a></li><li><a class="is-flex" href="#Calculus-of-Communicating-Systems-CCS"><span class="mr-2">1.4</span><span>Calculus of Communicating Systems (CCS)</span></a><ul class="menu-list"><li><a class="is-flex" href="#CCS"><span class="mr-2">1.4.1</span><span>CCS</span></a></li><li><a class="is-flex" href="#Processes"><span class="mr-2">1.4.2</span><span>Processes</span></a></li><li><a class="is-flex" href="#Action-Prefixing"><span class="mr-2">1.4.3</span><span>Action Prefixing</span></a></li><li><a class="is-flex" href="#Loops"><span class="mr-2">1.4.4</span><span>Loops</span></a></li><li><a class="is-flex" href="#Equality-of-Processes"><span class="mr-2">1.4.5</span><span>Equality of Processes</span></a></li><li><a class="is-flex" href="#Choice"><span class="mr-2">1.4.6</span><span>Choice</span></a></li><li><a class="is-flex" href="#Bisimulation-equivalence"><span class="mr-2">1.4.7</span><span>Bisimulation equivalence</span></a></li><li><a class="is-flex" href="#Partial-trace-equivalence"><span class="mr-2">1.4.8</span><span>Partial trace equivalence</span></a></li><li><a class="is-flex" href="#Parallel-Composition"><span class="mr-2">1.4.9</span><span>Parallel Composition</span></a></li><li><a class="is-flex" href="#Synchronization"><span class="mr-2">1.4.10</span><span>Synchronization</span></a></li><li><a class="is-flex" href="#Expansion-Theorem"><span class="mr-2">1.4.11</span><span>Expansion Theorem</span></a></li><li><a class="is-flex" href="#Restriction"><span class="mr-2">1.4.12</span><span>Restriction</span></a></li><li><a class="is-flex" href="#Inference-Rules"><span class="mr-2">1.4.13</span><span>Inference Rules</span></a></li><li><a class="is-flex" href="#Operational-Semantics"><span class="mr-2">1.4.14</span><span>Operational Semantics</span></a></li><li><a class="is-flex" href="#Bisimulation-Equivalence"><span class="mr-2">1.4.15</span><span>Bisimulation Equivalence</span></a></li><li><a class="is-flex" href="#Proof-Trees"><span class="mr-2">1.4.16</span><span>Proof Trees</span></a></li><li><a class="is-flex" href="#Value-Passing"><span class="mr-2">1.4.17</span><span>Value Passing</span></a></li><li><a class="is-flex" href="#Merge-and-Guards"><span class="mr-2">1.4.18</span><span>Merge and Guards</span></a></li><li><a class="is-flex" href="#Assignment"><span class="mr-2">1.4.19</span><span>Assignment</span></a></li></ul></li><li><a class="is-flex" href="#LTS-Labelled-Transition-Systems"><span class="mr-2">1.5</span><span>LTS Labelled Transition Systems</span></a><ul class="menu-list"><li><a class="is-flex" href="#Transition-Diagrams"><span class="mr-2">1.5.1</span><span>Transition Diagrams</span></a></li><li><a class="is-flex" href="#Floyd-Verification"><span class="mr-2">1.5.2</span><span>Floyd Verification</span></a></li><li><a class="is-flex" href="#Adding-Concurrency"><span class="mr-2">1.5.3</span><span>Adding Concurrency</span></a></li><li><a class="is-flex" href="#State-Space-Explosion"><span class="mr-2">1.5.4</span><span>State Space Explosion</span></a></li><li><a class="is-flex" href="#Owicki-Gries-Method"><span class="mr-2">1.5.5</span><span>Owicki-Gries Method</span></a></li><li><a class="is-flex" href="#One-Big-Invariant"><span class="mr-2">1.5.6</span><span>One Big Invariant</span></a></li></ul></li><li><a class="is-flex" href="#Compeleteness-criteria"><span class="mr-2">1.6</span><span>Compeleteness criteria</span></a><ul class="menu-list"><li><a class="is-flex" href="#Progress"><span class="mr-2">1.6.1</span><span>Progress</span></a></li><li><a class="is-flex" href="#Weak-Fairness"><span class="mr-2">1.6.2</span><span>Weak Fairness</span></a></li><li><a class="is-flex" href="#Strong-Fairness"><span class="mr-2">1.6.3</span><span>Strong Fairness</span></a></li><li><a class="is-flex" href="#Justness"><span class="mr-2">1.6.4</span><span>Justness</span></a></li></ul></li><li><a class="is-flex" href="#Scheduling"><span class="mr-2">1.7</span><span>Scheduling</span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/notes/"><span class="level-start"><span class="level-item">notes</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-11T07:00:00.000Z">2020-08-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/11/Operating%20System/">Operating system</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/notes/">notes</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-10T07:00:00.000Z">2020-08-10</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/10/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84blog/">建立自己的blog</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/notes/">notes</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-09T04:00:00.000Z">2020-08-09</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/09/Foundation%20of%20Concurrency/">Foundation of Concurrency</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/notes/">notes</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="QueenieJi" height="28"></a><p class="size-small"><span>&copy; 2020 Queenie Ji</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://QueenieJi.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="/live2d-widget-model-hijiki/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2d-widget-model-hijiki/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2d-widget-model-hijiki/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"emoji":{"enable":true,"className":"github-emoji","styles":null,"customEmojis":null},"log":false});</script></body></html>